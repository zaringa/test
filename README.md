# test

# Отчёт по реализации TCP-сервера и TCP-клиента для передачи файла

## Общий принцип работы

- **TCP** обеспечивает надежное соединение между клиентом и сервером.
- **Сервер** сначала "слушает" указанный порт, ожидая входящих подключений.
- **Клиент** подключается к серверу по IP-адресу и порту.
- После установления соединения данные передаются в виде потока байтов.
- TCP гарантирует доставку всех байтов в правильном порядке, что обеспечивает целостность передаваемых данных.

---

## Реализация сервера (`src/tcp_server.py`)

### parse_args()

Использует модуль `argparse` для обработки аргументов командной строки:
- `--file`: путь к файлу, который необходимо отправить клиенту.
- `--host`: IP-адрес сервера (по умолчанию `127.0.0.1`).
- `--port`: порт для прослушивания (по умолчанию `8000`).

Это позволяет запускать сервер с разными параметрами.

### send_file(conn, file_path)

Функция отвечает за отправку файла клиенту:
- Получает размер файла с помощью `os.path.getsize()`.
- Отправляет размер файла в виде строки длиной 16 байт, дополненной пробелами (`str(size).ljust(16)`).
- Открывает файл в бинарном режиме (`"rb"`).
- Читает файл блоками по 4096 байт.
- Каждый блок отправляется через `conn.sendall()`.

### handle_client(conn, addr, file_path)

Обрабатывает соединение с конкретным клиентом:
- Выводит информацию о подключении (IP и порт).
- Вызывает `send_file()` для отправки файла.
- Закрывает соединение.

### main()

Основная функция сервера:
- Создает TCP-сокет (`socket.socket(socket.AF_INET, socket.SOCK_STREAM)`).
- Связывает его с указанным IP и портом (`s.bind((host, port))`).
- Начинает прослушивание входящих соединений (`s.listen()`).
- В цикле принимает входящие подключения (`s.accept()`), получая новый сокет и адрес клиента.
- Обрабатывает каждое соединение вызовом `handle_client()`.
  
---

## Реализация клиента (`src/tcp_client.py`)

### parse_args()

Аналогично серверу, парсит аргументы командной строки:
- `--host`: IP сервера.
- `--port`: порт сервера.
- `--output`: имя файла для сохранения полученных данных.

### receive_file(s, output_file)

Функция получения файла:
- Сначала получает размер файла в виде строки длиной 16 байт (`s.recv(16)`), преобразует его в целое число.
- Открывает файл для записи в бинарном режиме (`"wb"`).
- В цикле читает данные блоками по 4096 байт с помощью `s.recv()`.
- Записывает полученные данные в файл.
- Повторяет до тех пор, пока не получит весь файл.

### main()

Создает TCP-сокет, подключается к серверу (`s.connect((host, port))`), вызывает `receive_file()` для получения файла и закрывает сокет.

---

## Тестирование (`test/test.sh`)

Тестовая схема включает:

1. Создание исходного файла `original.dat` размером 1 МБ со случайным содержимым командой:
   ```bash
   dd if=/dev/urandom of=original.dat bs=1M count=1
   ```
2. Запуск сервера в фоновом режиме с передачей имени файла:
   ```bash
   python3 src/tcp_server.py --file original.dat --host 127.0.0.1 --port 8000 &
   ```
3. Запуск клиента для получения файла:
   ```bash
   python3 src/tcp_client.py --host 127.0.0.1 --port 8000 --output received.dat
   ```
4. После завершения передачи сравниваются файлы командой:
   ```bash
   diff original.dat received.dat
   ```
   
Если файлы совпадают — тест считается пройденным.

---

## Итог

Данная реализация демонстрирует работу надежного обмена данными по протоколу TCP между сервером и клиентом:

| Компонент             | Основные функции                                              |
|------------------------|--------------------------------------------------------------|
| **tcp_server.py**      | Ожидает входящие соединения, отправляет указанный файл        |
| **tcp_client.py**      | Подключается к серверу, принимает файл и сохраняет его        |
| **test/test.sh**       | Автоматизированное тестирование корректности передачи данных |

Все компоненты обеспечивают надежную передачу файла с контрольной проверкой целостности посредством сравнения исходного и полученного файлов.

# Отчёт по реализации UDP клиента и сервера для передачи файла

## Общий принцип работы

- **UDP** — это протокол без установления соединения, не гарантирующий доставку и порядок доставки пакетов.
- Для передачи файла по UDP необходимо реализовать собственную логику контроля целостности и завершения передачи.
- В данной реализации:
  - **Сервер** слушает порт, ожидая запрос на скачивание файла.
  - **Клиент** посылает запрос серверу.
  - Сервер отправляет файл по частям (пакетами).
  - Передача завершается специальным пакетом `b"END"`.
  - Клиент собирает полученные части и сохраняет файл.

---

## Реализация сервера (`src/udp_server.py`)

### parse_args()

Использует `argparse` для обработки аргументов командной строки:
- `--file`: путь к файлу для отправки.
- `--host`: IP-адрес сервера (по умолчанию `127.0.0.1`).
- `--port`: порт для прослушивания (по умолчанию `8000`).

Это позволяет запускать сервер с разными параметрами.

### handle_client(sock, addr, file_path)

Обрабатывает запрос клиента:
- Получает сообщение от клиента (ожидается запрос типа `b"RQST"`).
- Вызывает функцию `send_file()` для отправки файла.

### send_file(sock, addr, file_path)

Отправляет файл клиенту:
- Получает размер файла с помощью `os.path.getsize()`.
- Отправляет размер файла в виде строки длиной 16 байт (`str(size).ljust(16)`).
- Открывает файл в бинарном режиме (`"rb"`).
- Читает файл блоками по 4096 байт.
- Каждый блок отправляется через `sock.sendto()`.
- После окончания передачи отправляется специальный пакет `b"END"`.

### main()

Создает UDP-сокет (`socket.socket(socket.AF_INET, socket.SOCK_DGRAM)`), связывает его с IP и портом, и в бесконечном цикле принимает входящие сообщения. При получении запроса вызывает обработчик.

---

## Реализация клиента (`src/udp_client.py`)

### parse_args()

Обрабатывает аргументы командной строки:
- `--host`: IP сервера.
- `--port`: порт сервера.
- `--output`: имя файла для сохранения.

### receive_file(sock, server_addr, output_file)

Получает файл:
- Сначала получает размер файла (`s.recv(16)`), преобразует в число.
- Создает файл для записи (`"wb"`).
- В цикле принимает пакеты по 4096 байт (`sock.recv(4096)`).
- Записывает данные в файл.
- Завершает работу при получении пакета `b"END"` или когда получено все байты.

### main()

Создает UDP-сокет, посылает серверу запрос (`b"RQST"`), вызывает функцию получения файла и закрывает сокет.

---

## Тестирование (`test/test.sh`)

1. Создается исходный файл `original.dat` размером 1 МБ со случайным содержимым командой:
   ```bash
   dd if=/dev/urandom of=original.dat bs=1M count=1
   ```
2. Запускается UDP-сервер в фоновом режиме с передачей имени файла:
   ```bash
   python3 src/udp_server.py --file original.dat --host 127.0.0.1 --port 8000 &
   ```
3. Запускается клиент для получения файла:
   ```bash
   python3 src/udp_client.py --host 127.0.0.1 --port 8000 --output received.dat
   ```
4. После завершения передачи сравниваются файлы командой:
   ```bash
   diff original.dat received.dat
   ```
   
Если файлы совпадают — тест считается успешным.

---

## Итог

| Компонент             | Основные функции                                              |
|------------------------|--------------------------------------------------------------|
| **udp_server.py**     | Ожидает запросы, отправляет файл частями, завершает передачу специальным пакетом |
| **udp_client.py**     | Посылает запрос, принимает части файла, собирает и сохраняет его |
| **test/test.sh**      | Автоматизированное тестирование корректности передачи данных |

Данная реализация демонстрирует работу надежной передачи файла по протоколу UDP с использованием собственных механизмов контроля завершения и целостности данных.


# как запустить
sudo apt install python3-venv
python3 -m venv myenv
source myenv/bin/activate
cd test
chmod -x test.sh
./test.sh